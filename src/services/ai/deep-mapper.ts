/**
 * Deep Mapper Service
 * Maps analyzed website elements to Catppuccin colors using AI
 *
 * This is the intelligence layer that connects deep analysis ‚Üí Catppuccin palette
 */

import type {
  DeepAnalysisResult,
  MappingResult,
  VariableMapping,
  SVGColorMapping,
  SelectorMapping,
  CSSVariable,
  SVGInfo,
  SelectorGroup,
} from '../../types/deep-analysis';
import type { CatppuccinFlavor, CatppuccinAccent } from '../../types/catppuccin';
import type { AIProvider } from '../../types/theme';
import { analyzeColorsWithAI as analyzeWithOpenRouter } from './openrouter';
import { analyzeColorsWithAI as analyzeWithChutes } from './chutes';
import { analyzeColorsWithAI as analyzeWithOllama } from './ollama';

/**
 * Deep mapper configuration
 */
export interface DeepMapperConfig {
  provider: AIProvider;
  apiKey?: string;
  model?: string;
  mainAccent: CatppuccinAccent;
  flavor: CatppuccinFlavor;
  enableVariableMapping: boolean;
  enableSVGMapping: boolean;
  enableSelectorMapping: boolean;
  debug?: boolean;
}

/**
 * Main deep mapping function
 * Takes deep analysis result and generates comprehensive Catppuccin mappings
 */
export async function mapWithDeepAnalysis(
  analysis: DeepAnalysisResult,
  config: DeepMapperConfig
): Promise<MappingResult> {
  console.log('üß† Starting deep AI mapping...');
  console.log(`   Provider: ${config.provider}`);
  console.log(`   Main Accent: ${config.mainAccent}`);
  console.log(`   Flavor: ${config.flavor}`);

  const startTime = Date.now();

  // Step 1: Map CSS Variables (Priority 1 - 90% effectiveness)
  const variableMappings = config.enableVariableMapping && analysis.cssVariables.length > 0
    ? await mapCSSVariables(analysis.cssVariables, analysis, config)
    : [];

  // Step 2: Map SVG Colors (Priority 2 - Perfect icon accuracy)
  const svgMappings = config.enableSVGMapping && analysis.svgs.length > 0
    ? await mapSVGColors(analysis.svgs, analysis, config)
    : new Map();

  // Step 3: Map Selectors (Priority 3 - Site-specific patterns)
  const selectorMappings = config.enableSelectorMapping && analysis.selectorGroups.length > 0
    ? await mapSelectors(analysis.selectorGroups, analysis, config)
    : [];

  const mappingTime = Date.now() - startTime;

  console.log(`‚úÖ Deep mapping complete in ${mappingTime}ms`);
  console.log(`   Variables mapped: ${variableMappings.length}`);
  console.log(`   SVGs processed: ${svgMappings.size}`);
  console.log(`   Selectors mapped: ${selectorMappings.length}`);

  return {
    variableMappings,
    svgMappings,
    selectorMappings,
    processedSVGs: [], // Will be generated by userstyle-v2.ts
    coverage: {
      variablePercentage: calculateCoverage(variableMappings.length, analysis.cssVariables.length),
      svgPercentage: calculateCoverage(svgMappings.size, analysis.svgs.length),
      selectorPercentage: calculateCoverage(
        selectorMappings.length,
        analysis.selectorGroups.reduce((sum, g) => sum + g.totalCount, 0)
      ),
    },
    mappingTime,
  };
}

/**
 * Map CSS Variables to Catppuccin colors
 */
async function mapCSSVariables(
  variables: CSSVariable[],
  analysis: DeepAnalysisResult,
  config: DeepMapperConfig
): Promise<VariableMapping[]> {
  console.log('üé® Mapping CSS variables...');

  // Filter to color variables only
  const colorVariables = variables.filter(v => {
    const value = (v.computedValue || v.value).toLowerCase();
    return value.startsWith('#') ||
           value.startsWith('rgb') ||
           value.startsWith('hsl') ||
           value.includes('color');
  });

  if (colorVariables.length === 0) {
    console.log('   No color variables found');
    return [];
  }

  // Group by semantic purpose
  const grouped = groupVariablesByPurpose(colorVariables);

  // Build prompt for AI
  const prompt = buildCSSVariablePrompt(grouped, analysis, config);

  // Call AI provider
  const response = await callAIProvider(prompt, config);

  // Parse response
  const mappings = parseCSSVariableMappings(response, colorVariables);

  console.log(`   Mapped ${mappings.length} variables`);
  return mappings;
}

/**
 * Map SVG colors to Catppuccin colors
 */
async function mapSVGColors(
  svgs: SVGInfo[],
  analysis: DeepAnalysisResult,
  config: DeepMapperConfig
): Promise<Map<string, SVGColorMapping>> {
  console.log('üñºÔ∏è  Mapping SVG colors...');

  // Extract all unique colors from SVGs
  const colorUsage = new Map<string, { count: number; svgs: string[] }>();

  svgs.forEach(svg => {
    svg.colors.forEach(color => {
      const existing = colorUsage.get(color.value) || { count: 0, svgs: [] };
      existing.count++;
      if (!existing.svgs.includes(svg.selector)) {
        existing.svgs.push(svg.selector);
      }
      colorUsage.set(color.value, existing);
    });
  });

  if (colorUsage.size === 0) {
    console.log('   No SVG colors found');
    return new Map();
  }

  // Build prompt for AI
  const prompt = buildSVGColorPrompt(colorUsage, analysis, config);

  // Call AI provider
  const response = await callAIProvider(prompt, config);

  // Parse response
  const mappings = parseSVGColorMappings(response);

  console.log(`   Mapped ${mappings.size} SVG colors`);
  return mappings;
}

/**
 * Map selectors to Catppuccin colors
 */
async function mapSelectors(
  groups: SelectorGroup[],
  analysis: DeepAnalysisResult,
  config: DeepMapperConfig
): Promise<SelectorMapping[]> {
  console.log('üéØ Mapping selectors...');

  // Filter to groups with color properties
  const colorGroups = groups.filter(g => g.selectors.some(s =>
    s.currentStyles.color ||
    s.currentStyles.backgroundColor ||
    s.currentStyles.borderColor ||
    s.currentStyles.fill ||
    s.currentStyles.stroke
  ));

  if (colorGroups.length === 0) {
    console.log('   No color selectors found');
    return [];
  }

  // Build prompt for AI
  const prompt = buildSelectorPrompt(colorGroups, analysis, config);

  // Call AI provider
  const response = await callAIProvider(prompt, config);

  // Parse response
  const mappings = parseSelectorMappings(response, colorGroups);

  console.log(`   Mapped ${mappings.length} selectors`);
  return mappings;
}

/**
 * Group variables by semantic purpose
 */
function groupVariablesByPurpose(variables: CSSVariable[]): Map<string, CSSVariable[]> {
  const groups = new Map<string, CSSVariable[]>();

  const purposes = [
    { key: 'background', patterns: ['bg', 'background', 'surface', 'base'] },
    { key: 'text', patterns: ['text', 'txt', 'fg', 'foreground'] },
    { key: 'accent', patterns: ['accent', 'primary', 'link', 'button', 'active'] },
    { key: 'border', patterns: ['border', 'outline', 'divider'] },
    { key: 'hover', patterns: ['hover', 'focus', 'active'] },
    { key: 'other', patterns: [] },
  ];

  variables.forEach(v => {
    const name = v.name.toLowerCase();
    let assigned = false;

    for (const purpose of purposes) {
      if (purpose.patterns.some(pattern => name.includes(pattern))) {
        if (!groups.has(purpose.key)) {
          groups.set(purpose.key, []);
        }
        groups.get(purpose.key)!.push(v);
        assigned = true;
        break;
      }
    }

    if (!assigned) {
      if (!groups.has('other')) {
        groups.set('other', []);
      }
      groups.get('other')!.push(v);
    }
  });

  return groups;
}

/**
 * Build CSS variable mapping prompt
 */
function buildCSSVariablePrompt(
  grouped: Map<string, CSSVariable[]>,
  analysis: DeepAnalysisResult,
  config: DeepMapperConfig
): string {
  const { mainAccent, flavor } = config;

  let prompt = `You are a CSS theming expert. Map CSS variables to Catppuccin ${flavor} palette colors.

üé® **CATPPUCCIN ${flavor.toUpperCase()} PALETTE**:
- **Base colors**: base, mantle, crust (backgrounds)
- **Surface colors**: surface0, surface1, surface2 (elevated surfaces)
- **Text colors**: text, subtext0, subtext1 (text hierarchy)
- **Overlay colors**: overlay0, overlay1, overlay2 (overlays/modals)
- **Accent colors**: rosewater, flamingo, pink, mauve, red, maroon, peach, yellow, green, teal, sky, sapphire, blue, lavender

üéØ **MAIN ACCENT**: ${mainAccent} (use for 70-80% of interactive elements)

üìä **WEBSITE ANALYSIS**:
- Design System: ${analysis.designSystem.framework} (${Math.round(analysis.designSystem.confidence * 100)}% confidence)
- Color Scheme: ${analysis.mode} mode
- Total Variables: ${Array.from(grouped.values()).reduce((sum, arr) => sum + arr.length, 0)}

üìù **CSS VARIABLES TO MAP**:

`;

  // Add each group
  for (const [purpose, vars] of grouped.entries()) {
    if (vars.length === 0) continue;

    prompt += `\n**${purpose.toUpperCase()} VARIABLES** (${vars.length}):\n`;

    // Show top 10 most-used variables per group
    const topVars = vars
      .sort((a, b) => b.frequency - a.frequency)
      .slice(0, 10);

    topVars.forEach((v, i) => {
      prompt += `${i + 1}. ${v.name}: ${v.computedValue || v.value} (used ${v.frequency} times)\n`;
    });

    if (vars.length > 10) {
      prompt += `   ... and ${vars.length - 10} more\n`;
    }
  }

  prompt += `

üéØ **MAPPING STRATEGY**:

1. **Background variables** ‚Üí base, mantle, surface0-2
   - Main backgrounds ‚Üí base
   - Elevated surfaces ‚Üí surface0, surface1, surface2 (lighter = higher elevation)
   - Very dark accents ‚Üí mantle or crust

2. **Text variables** ‚Üí text, subtext0, subtext1
   - Primary text ‚Üí text
   - Secondary/muted text ‚Üí subtext0, subtext1
   - Disabled text ‚Üí overlay0

3. **Accent variables** ‚Üí ${mainAccent} (70-80%) + sapphire/lavender (20-30%)
   - Primary buttons, links, CTAs ‚Üí ${mainAccent}
   - Active states, selections ‚Üí ${mainAccent}
   - Secondary accents ‚Üí Use analogous colors (sapphire, lavender, etc.)
   - Error states ‚Üí red or maroon
   - Success states ‚Üí green or teal
   - Warning states ‚Üí yellow or peach

4. **Border variables** ‚Üí overlay0, overlay1, overlay2, or accent colors
   - Subtle borders ‚Üí overlay0, overlay1
   - Emphasized borders ‚Üí accent colors

5. **Hover/Focus variables** ‚Üí Brighter version of base color or ${mainAccent}

‚ö†Ô∏è **CRITICAL RULES**:
- Use ${mainAccent} for 70-80% of colored/interactive elements
- Use bi-accents (sapphire, lavender) for 20-30% variety only
- Maintain semantic meaning (error=red, success=green, warning=yellow)
- Preserve visual hierarchy (text > subtext0 > subtext1)
- Map light mode variables if analysis.mode is 'light'

üì§ **OUTPUT FORMAT** (JSON):
\`\`\`json
{
  "mappings": [
    {
      "variable": "--theme-col-txt-title",
      "catppuccinColor": "${mainAccent}",
      "reasoning": "Primary text/title color, maps to main accent"
    },
    {
      "variable": "--theme-col-bg-page",
      "catppuccinColor": "base",
      "reasoning": "Main page background"
    }
  ]
}
\`\`\`

Return ONLY valid JSON. Map ALL variables listed above.`;

  return prompt;
}

/**
 * Build SVG color mapping prompt
 */
function buildSVGColorPrompt(
  colorUsage: Map<string, { count: number; svgs: string[] }>,
  analysis: DeepAnalysisResult,
  config: DeepMapperConfig
): string {
  const { mainAccent, flavor } = config;

  let prompt = `You are a color theming expert. Map SVG colors to Catppuccin ${flavor} palette.

üé® **CATPPUCCIN ACCENT COLORS**:
rosewater, flamingo, pink, mauve, red, maroon, peach, yellow, green, teal, sky, sapphire, blue, lavender

üéØ **MAIN ACCENT**: ${mainAccent}

üñºÔ∏è **SVG COLORS TO MAP**:

`;

  const sortedColors = Array.from(colorUsage.entries())
    .sort((a, b) => b[1].count - a[1].count);

  sortedColors.forEach(([color, usage], i) => {
    prompt += `${i + 1}. ${color} (used in ${usage.count} SVG${usage.count > 1 ? 's' : ''})\n`;
    prompt += `   Locations: ${usage.svgs.slice(0, 3).join(', ')}${usage.svgs.length > 3 ? '...' : ''}\n`;
  });

  prompt += `

üéØ **MAPPING STRATEGY**:
1. Map MOST colors to ${mainAccent} (maintain 70-80% rule)
2. Use semantic colors when obvious:
   - Red/pink ‚Üí red or maroon
   - Green ‚Üí green or teal
   - Yellow/orange ‚Üí yellow or peach
   - Blue ‚Üí ${mainAccent === 'blue' ? 'blue' : mainAccent}
3. Use bi-accents (sapphire, lavender) for variety (20-30%)
4. Preserve multi-color logos by mapping each color semantically

üì§ **OUTPUT FORMAT** (JSON):
\`\`\`json
{
  "mappings": {
    "#1a73e8": "${mainAccent}",
    "#de5833": "peach",
    "#5b9e4d": "green"
  }
}
\`\`\`

Return ONLY valid JSON mapping all colors above.`;

  return prompt;
}

/**
 * Build selector mapping prompt
 */
function buildSelectorPrompt(
  groups: SelectorGroup[],
  analysis: DeepAnalysisResult,
  config: DeepMapperConfig
): string {
  const { mainAccent, flavor } = config;

  let prompt = `You are a CSS theming expert. Map website selectors to Catppuccin ${flavor} colors.

üé® **CATPPUCCIN PALETTE**:
- Base: base, mantle, crust, surface0-2
- Text: text, subtext0, subtext1
- Accents: ${mainAccent} (MAIN), sapphire, lavender, and others

üéØ **MAIN ACCENT**: ${mainAccent} (use for 70-80% of elements)

üìä **SELECTOR CATEGORIES**:

`;

  groups.forEach(group => {
    prompt += `\n**${group.category.toUpperCase()}** (${group.totalCount} selectors):\n`;

    const topSelectors = group.selectors.slice(0, 5);
    topSelectors.forEach((sel, i) => {
      const styles = [];
      if (sel.currentStyles.color) styles.push(`color: ${sel.currentStyles.color}`);
      if (sel.currentStyles.backgroundColor) styles.push(`bg: ${sel.currentStyles.backgroundColor}`);
      if (sel.currentStyles.borderColor) styles.push(`border: ${sel.currentStyles.borderColor}`);

      prompt += `${i + 1}. ${sel.selector}\n`;
      prompt += `   Current: ${styles.join(', ')}\n`;
      prompt += `   Frequency: ${sel.frequency}, Interactive: ${sel.isInteractive}\n`;
    });

    if (group.totalCount > 5) {
      prompt += `   ... and ${group.totalCount - 5} more\n`;
    }
  });

  prompt += `

üéØ **MAPPING STRATEGY**:
1. **Buttons** ‚Üí ${mainAccent} background + base text (70-80%)
   - Some buttons ‚Üí sapphire or lavender for variety (20-30%)
2. **Links** ‚Üí ${mainAccent} (maintain 70-80% rule)
3. **Text** ‚Üí text, subtext0, subtext1 (hierarchy)
4. **Backgrounds** ‚Üí base, surface0-2 (elevation)
5. **Borders** ‚Üí overlay0-2 or accent colors
6. **Interactive states** ‚Üí ${mainAccent} or brighter accent

üì§ **OUTPUT FORMAT** (JSON):
\`\`\`json
{
  "mappings": [
    {
      "category": "button",
      "color": "${mainAccent}",
      "backgroundColor": "${mainAccent}",
      "textColor": "base",
      "distribution": "70%"
    },
    {
      "category": "link",
      "color": "${mainAccent}",
      "distribution": "80%"
    }
  ]
}
\`\`\`

Return ONLY valid JSON with mappings for each category.`;

  return prompt;
}

/**
 * Call AI provider with prompt
 */
async function callAIProvider(prompt: string, config: DeepMapperConfig): Promise<string> {
  const { provider, apiKey, model } = config;

  // Dummy crawl result for compatibility
  const dummyCrawl = {
    url: '',
    title: '',
    content: '',
    colors: [],
    mode: 'light' as const,
  };

  try {
    switch (provider) {
      case 'openrouter':
        return await analyzeWithOpenRouter(dummyCrawl, config.mainAccent, apiKey || '', model, prompt);

      case 'chutes':
        return await analyzeWithChutes(dummyCrawl, config.mainAccent, apiKey || '', model, prompt);

      case 'ollama':
        return await analyzeWithOllama(dummyCrawl, config.mainAccent, model || 'llama3.2', prompt);

      default:
        throw new Error(`Unknown AI provider: ${provider}`);
    }
  } catch (error) {
    console.error(`AI provider error:`, error);
    throw error;
  }
}

/**
 * Parse CSS variable mappings from AI response
 */
function parseCSSVariableMappings(response: string, variables: CSSVariable[]): VariableMapping[] {
  try {
    // Extract JSON from response
    const jsonMatch = response.match(/\{[\s\S]*\}/);
    if (!jsonMatch) {
      throw new Error('No JSON found in response');
    }

    const parsed = JSON.parse(jsonMatch[0]);
    const mappings: VariableMapping[] = [];

    if (parsed.mappings && Array.isArray(parsed.mappings)) {
      parsed.mappings.forEach((m: any) => {
        const variable = variables.find(v => v.name === m.variable);
        if (variable) {
          mappings.push({
            variable: m.variable,
            originalValue: variable.computedValue || variable.value,
            catppuccinColor: m.catppuccinColor,
            scope: variable.scope,
            usage: variable.usage,
            frequency: variable.frequency,
            reasoning: m.reasoning,
          });
        }
      });
    }

    return mappings;
  } catch (error) {
    console.error('Failed to parse variable mappings:', error);
    return [];
  }
}

/**
 * Parse SVG color mappings from AI response
 */
function parseSVGColorMappings(response: string): Map<string, SVGColorMapping> {
  try {
    const jsonMatch = response.match(/\{[\s\S]*\}/);
    if (!jsonMatch) {
      throw new Error('No JSON found in response');
    }

    const parsed = JSON.parse(jsonMatch[0]);
    const mappings = new Map<string, SVGColorMapping>();

    if (parsed.mappings && typeof parsed.mappings === 'object') {
      Object.entries(parsed.mappings).forEach(([originalColor, catppuccinColor]) => {
        mappings.set(originalColor, {
          originalColor,
          catppuccinColor: catppuccinColor as CatppuccinAccent,
          reasoning: `Mapped by AI`,
        });
      });
    }

    return mappings;
  } catch (error) {
    console.error('Failed to parse SVG mappings:', error);
    return new Map();
  }
}

/**
 * Parse selector mappings from AI response
 */
function parseSelectorMappings(response: string, groups: SelectorGroup[]): SelectorMapping[] {
  try {
    const jsonMatch = response.match(/\{[\s\S]*\}/);
    if (!jsonMatch) {
      throw new Error('No JSON found in response');
    }

    const parsed = JSON.parse(jsonMatch[0]);
    const mappings: SelectorMapping[] = [];

    if (parsed.mappings && Array.isArray(parsed.mappings)) {
      parsed.mappings.forEach((m: any) => {
        const group = groups.find(g => g.category === m.category);
        if (group) {
          mappings.push({
            category: m.category,
            selectors: group.selectors.map(s => s.selector),
            color: m.color,
            backgroundColor: m.backgroundColor,
            borderColor: m.borderColor,
            distribution: m.distribution || '100%',
            reasoning: m.reasoning,
          });
        }
      });
    }

    return mappings;
  } catch (error) {
    console.error('Failed to parse selector mappings:', error);
    return [];
  }
}

/**
 * Calculate coverage percentage
 */
function calculateCoverage(mapped: number, total: number): number {
  if (total === 0) return 0;
  return Math.round((mapped / total) * 100);
}
