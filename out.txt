import type { CatppuccinFlavor, CatppuccinColor, ColorMapping, AccentColor } from '../../types/catppuccin';
import type { MappingOutput, RoleMap, DerivedScales } from '../../types/theme';
import { CATPPUCCIN_PALETTES } from '../../constants/catppuccin-colors';
import { computeAccentSetFor } from '../../utils/accent-schemes';

// Contrast calculation functions
function hexToRgb(hex: string): number[] {
  // Remove # if present
  const h = hex.replace(/#/, '');
  // Split the string into 2-digit pairs
  const rgb = h.match(/../g) || [];
  // Convert each pair into a number and divide by 255
  return rgb.map((v) => parseInt(v, 16) / 255);
}

function luminance(rgb: number[]): number {
  // Scale to 0-1
  const r = rgb[0] / 255;
  const g = rgb[1] / 255;
  const b = rgb[2] / 255;
  // Convert to XYZ using D65 white point
  const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
  const y = r * 0.3993 + g * 0.3685 + b * 0.1855;
  const z = r * 0.2101 + g * 0.1140 + b * 0.9500;
  // Calculate luminance (perceived brightness)
  return (0.2126 * x + 0.7152 * y + 0.0722 * z) / (1 - 0.05); // Adjusting for relative luminance
}

function contrastRatio(hex1: string, hex2: string): number {
  // Convert hex colors to RGB
  const rgb1 = hexToRgb(hex1);
  const rgb2 = hexToRgb(hex2);
  // Calculate relative luminance for each color
  const lum1 = luminance(rgb1);
  const lum2 = luminance(rgb2);
  // Calculate contrast ratio
  const contrast = (Math.max(lum1, lum2) + 0.05) / (Math.min(lum1, lum2) + 0.05);
  return contrast;
}

/**
 * generateStylusTheme
 * Supports legacy input (Map + optional mappingsWithReasons) OR MappingOutput.
 * Emits two-level variables when MappingOutput is provided:
 * - Level 1: $cp_* color bindings
 * - Level 2: $role-name variables referencing level 1
 */
export function generateStylusTheme(
  flavor: CatppuccinFlavor,
  colorMappings: Map<string, CatppuccinColor> | MappingOutput,
  url: string,
  mappingsWithReasons?: ColorMapping[],
  defaultAccent: AccentColor = 'mauve',
  cssAnalysis?: any
): string {
  const palette = CATPPUCCIN_PALETTES[flavor];
  const pre = computeAccentSetFor(palette, defaultAccent);
  const bi1Set = computeAccentSetFor(palette, pre.biAccent1);
  const bi2Set = computeAccentSetFor(palette, pre.biAccent2);
  const useAltForSecondary = Math.random() < 0.5 ? 'bi1' : 'bi2';
  const date = new Date().toISOString().split('T')[0];
  // Flavor-based intensity tuning (decimals for Stylus fade())
  const intensity = (() => {
    switch (flavor) {
      case 'latte':
        return { weak: 0.10, mid: 0.14, strong: 0.18, inputHover: 0.22 };
      case 'frappe':
        return { weak: 0.12, mid: 0.16, strong: 0.20, inputHover: 0.26 };
      case 'macchiato':
        return { weak: 0.12, mid: 0.16, strong: 0.20, inputHover: 0.28 };
      case 'mocha':
      default:
        return { weak: 0.12, mid: 0.16, strong: 0.20, inputHover: 0.28 };
    }
  })();

  let stylus = `/**
 * ============================================
 * Catppuccin ${capitalize(flavor)} Theme
 * ============================================
 *
 * Generated from: ${url}
 * Date: ${date}
 * Generator: Catppuccin Theme Generator
 *
 * This theme uses the Catppuccin ${capitalize(flavor)} color palette
 * to create a beautiful, consistent look for your website.
 */

/* ============================================
 * BASE COLOR PALETTE
 * ============================================
 * These are all the Catppuccin ${capitalize(flavor)} colors
 */

`;

  // Add base palette variables for reference
  const baseColors = ['base', 'mantle', 'crust'];
  const surfaceColors = ['surface0', 'surface1', 'surface2'];
  const overlayColors = ['overlay0', 'overlay1', 'overlay2'];
  const textColors = ['subtext0', 'subtext1', 'text'];
  const accentColors = ['rosewater', 'flamingo', 'pink', 'mauve', 'red', 'maroon',
                        'peach', 'yellow', 'green', 'teal', 'sky', 'sapphire',
                        'blue', 'lavender'];

  stylus += `// Palette reference\n`;
  [...baseColors, ...surfaceColors, ...overlayColors, ...textColors, ...accentColors].forEach(colorName => {
    const c = palette[colorName as CatppuccinColor];
    if (c) stylus += `${colorName} = ${c.hex}\n`;
  });

  // Add accent color scheme variables
  stylus += `\n// Accent Color Scheme Variables (Analogous Harmony)\n`;
  stylus += `// Main-colors: three analogous colors at ±72° for visual hierarchy\n`;
  stylus += `// Intensity tuning (decimals)\n`;
  stylus += `$tint_weak = ${intensity.weak}\n`;
  stylus += `$tint_mid = ${intensity.mid}\n`;
  stylus += `$tint_strong = ${intensity.strong}\n`;
  stylus += `$tint_input_hover = ${intensity.inputHover}\n`;
  stylus += `// Bi-accents (analogous colors at ±72° from ${defaultAccent})\n`;
  stylus += `$bi-accent1 = ${pre.biAccent1}\n`;
  stylus += `$bi-accent2 = ${pre.biAccent2}\n`;
  stylus += `$bi-accent = $bi-accent1\n`;

  // Decide hover accents for links at generation time (build-time random)
  // Build-time random angle and percentage stops for gradient text on link hover
  const hoverAngle = Math.floor(Math.random() * 180); // 0-179deg
  // Approx 40/20/20 style distribution
  const hoverMain = 38 + Math.floor(Math.random() * 8); // 38-45%
  const hoverRemain = 100 - hoverMain; // 55-62%
  let hoverB1 = Math.max(18, Math.floor(Math.random() * Math.max(18, hoverRemain - 18)));
  let hoverB2 = hoverRemain - hoverB1;
  if (hoverB1 > 45) { hoverB2 += (hoverB1 - 45); hoverB1 = 45; }
  if (hoverB2 > 45) { hoverB1 += (hoverB2 - 45); hoverB2 = 45; }

  // If MappingOutput, emit two-level system
  if ((colorMappings as MappingOutput)?.roleMap) {
    const mappingOutput = colorMappings as MappingOutput;
    const roleMap: RoleMap = mappingOutput.roleMap || {};
    const derived: DerivedScales = mappingOutput.derivedScales || {};

    stylus += `\n// ==========================\n// Level 1: cp_* color bindings\n// ==========================\n`;
    const seen = new Map<string, string>(); // hex -> cpName

    function cpNameForKey(key: string) {
      return `cp_${sanitizeKey(key)}`;
    }

    for (const [role, cv] of Object.entries(roleMap)) {
      if (!cv) continue;
      const hex = cv.hex;
      if (!seen.has(hex)) {
        const cp = cpNameForKey(role);
        seen.set(hex, cp);
        stylus += `${cp} = ${hex} // from role ${role}\n`;
      }
    }

    for (const [dkey, cv] of Object.entries(derived)) {
      if (!cv) continue;
      const hex = cv.hex;
      if (!seen.has(hex)) {
        const cp = cpNameForKey(dkey);
        seen.set(hex, cp);
        stylus += `${cp} = ${hex} // derived ${dkey}\n`;
      }
    }

    stylus += `\n// ==========================\n// Level 2: role variables\n// ==========================\n`;
    for (const [role, cv] of Object.entries(roleMap)) {
      if (!cv) continue;
      const cp = seen.get(cv.hex) || cpNameForKey(role);
      const roleVar = roleToVar(role);
      stylus += `${roleVar} = ${cp}\n`;
    }
    for (const [dkey, cv] of Object.entries(derived)) {
      if (!cv) continue;
      const cp = seen.get(cv.hex) || cpNameForKey(dkey);
      const roleVar = roleToVar(dkey);
      stylus += `${roleVar} = ${cp}\n`;
    }

    // Usage examples prefer role variables
    stylus += `\n/* =========================
 * LINK & BUTTON STYLES
 * Catppuccin Theme with Bi-Accent Gradients - Smooth & Elegant
 * =========================*/\n`;
    
    // Calculate contrast for link hover state
    const accentHex = palette[defaultAccent].hex;
    const bgHex = palette[pre.biAccent1].hex;
    const contrast = contrastRatio(accentHex, bgHex);
    
    stylus += `a, a.link
  color ${defaultAccent}
  text-decoration-color $bi-accent1
  text-decoration underline
  text-decoration-thickness 1.5px
  text-underline-offset 2px
  position relative
  &:hover, &:focus
    // Apply contrast-aware text color
    if (${contrast} < 4.5)
      color $text
    else
      color ${defaultAccent}
    // Gradient text only on WebKit with full support; otherwise keep solid
    @supports ((-webkit-background-clip: text) and (-webkit-text-fill-color: transparent))
      background linear-gradient(${hoverAngle}deg, ${defaultAccent} 0%, $bi-accent1 100%)
      -webkit-background-clip text
      -webkit-text-fill-color transparent
  &:active, &.active
    color $bi-accent1
    text-decoration-color $bi-accent2

`;

    // Calculate contrast for button hover state
    const btnTextHex = palette.blue.hex;
    const btnBgHex = palette.surface0.hex;
    const btnContrast = contrastRatio(btnTextHex, btnBgHex);
    
    stylus += `// Button styles - Catppuccin text colors with preserved or mapped backgrounds
.btn-primary
  /* Default: emphasize main accent on text */
  color ${defaultAccent}
  &:hover
    /* Apply gradient background on hover ONLY */
    background-image linear-gradient(135deg, ${defaultAccent} 0%, $bi-accent1 100%)
    // Prefer accent text; fallback to text if needed
    if (${btnContrast} < 4.5)
      color $text
    else
      color ${defaultAccent}
  &:active
    /* Apply reversed gradient on active */
    background-image linear-gradient(135deg, $bi-accent1 0%, ${defaultAccent} 100%)
    if (${btnContrast} < 4.5)
      color $text
    else
      color ${defaultAccent}
    border-color ${defaultAccent}
  &:focus-visible
    // Bi-accent focus ring for harmonious accessibility
    outline 2px solid $bi-accent1
    outline-offset 2px
    box-shadow 0 0 0 4px fade($bi-accent2, 0.25)

`;

    // Calculate contrast for secondary button hover state
    const secondaryBtnTextHex = useAltForSecondary === 'bi1' ?
      palette[pre.biAccent1].hex : palette[pre.biAccent2].hex;
    const secondaryBtnBgHex = palette.surface0.hex;
    const secondaryBtnContrast = contrastRatio(secondaryBtnTextHex, secondaryBtnBgHex);
    
    stylus += `.btn-secondary
  /* Default: Catppuccin text color */
  color ${useAltForSecondary === 'bi1' ? `${pre.biAccent1}` : `${pre.biAccent2}`}
  &:hover
    /* Apply gradient background on hover ONLY */
    background-image linear-gradient(135deg, ${useAltForSecondary === 'bi1' ? `${pre.biAccent1}` : `${pre.biAccent2}`} 0%, ${useAltForSecondary === 'bi1' ? `${bi1Set.biAccent1}` : `${bi2Set.biAccent1}`} 100%)
    // Prefer ALT main; fallback to text
    if (${secondaryBtnContrast} < 4.5)
      color $text
    else
      color ${useAltForSecondary === 'bi1' ? `${pre.biAccent1}` : `${pre.biAccent2}`}
    border-color ${useAltForSecondary === 'bi1' ? `${bi1Set.biAccent1}` : `${bi2Set.biAccent1}`}

`;

    // Calculate contrast for destructive button hover state
    const destructiveBtnTextHex = palette.red.hex;
    const destructiveBtnBgHex = palette.surface0.hex;
    const destructiveBtnContrast = contrastRatio(destructiveBtnTextHex, destructiveBtnBgHex);
    
    stylus += `.btn-destructive
  /* Default: Catppuccin red text color */
  color $red
  &:hover
    /* Apply gradient background on hover ONLY */
    /* CRITICAL: Text must contrast with gradient */
    color $text
    background-image linear-gradient(135deg, $red 0%, $maroon 50%, $peach 100%)

`;

    // Inputs - subtle surface backgrounds for text fields
    stylus += `/* INPUTS - Subtle backgrounds + focus */\n`;
    stylus += `input, textarea, select, input[type="text"], input[type="search"], input[type="email"], input[type="password"], input[type="url"], input[type="tel"], input[type="number"]\n  background-color fade($surface0, $tint_weak)\n  color $text\n  border-color $overlay0\n  caret-color $mauve\n  &::placeholder\n    color $subtext0\n    opacity .75\n  &:hover\n    border-color $overlay0\n    box-shadow none\n    background-color fade($surface0, $tint_weak)\n  &:focus\n    border-color $overlay1\n    outline 2px solid rgba($mauve, .35)\n    outline-offset 2px\n    box-shadow 0 0 0 2px rgba($mauve, .2)\n    background-color fade($surface0, $tint_input_hover)\n\n`;

  } else {
    // Legacy: fallback to mapping map / reasons
    if (mappingsWithReasons && mappingsWithReasons.length > 0) {
      const grouped = groupMappingsByPurpose(mappingsWithReasons);
      for (const [category, mappings] of Object.entries(grouped)) {
        stylus += `// ${category}\n`;
        mappings.forEach(mapping => {
          const varName = generateVarName(mapping.originalColor);
          stylus += `${varName} = ${mapping.catppuccinColor} // ${mapping.reason}\n`;
        });
        stylus += `\n`;
      }
    } else {
      const map = colorMappings as Map<string, CatppuccinColor>;
      for (const [originalColor, catppuccinColor] of map.entries()) {
        const varName = generateVarName(originalColor);
        stylus += `${varName} = ${catppuccinColor} // Original: ${originalColor}\n`;
      }
    }
  }

  // Ensure inputs use subtle surface backgrounds in legacy as well
  stylus += `\n/* INPUTS - Subtle backgrounds + focus */\n`;
  stylus += `input, textarea, select, input[type="text"], input[type="search"], input[type="email"], input[type="password"], input[type="url"], input[type="tel"], input[type="number"]\n  background-color fade($surface0, $tint_weak)\n  color $text\n  border-color $overlay0\n  caret-color $mauve\n  &::placeholder\n    color $subtext0\n    opacity .75\n  &:hover\n    border-color $overlay0\n    box-shadow none\n    background-color fade($surface0, $tint_weak)\n  &:focus\n    border-color $overlay1\n    outline 2px solid rgba($mauve, .35)\n    outline-offset 2px\n    box-shadow 0 0 0 2px rgba($mauve, .2)\n    background-color fade($surface0, $tint_input_hover)\n`;

  // Global polish: selection, scrollbar, focus, components
  stylus += `\n/* Text selection */\n`;
  stylus += `::selection\n  background fade($mauve, .35)\n  color $base\n`;
  stylus += `::-moz-selection\n  background fade($mauve, .35)\n  color $base\n`;

  stylus += `\n/* Scrollbar (WebKit) */\n`;
  stylus += `::-webkit-scrollbar\n  width 10px\n  height 10px\n`;
  stylus += `::-webkit-scrollbar-track\n  background $base\n`;
  stylus += `::-webkit-scrollbar-thumb\n  background fade($overlay2, .35)\n  border-radius 8px\n  border 2px solid $base\n`;
  stylus += `::-webkit-scrollbar-thumb:hover\n  background fade($overlay2, .5)\n`;

  stylus += `\n/* Global focus ring */\n`;
  stylus += `:focus-visible\n  outline 2px solid rgba($mauve, .35)\n  outline-offset 2px\n  box-shadow 0 0 0 2px rgba($mauve, .2)\n`;

  stylus += `\n/* Checkboxes / radios / switches */\n`;
  stylus += `input[type="checkbox"], input[type="radio"]\n  accent-color $mauve\n  background $surface_0\n  border-color $overlay0\n`;
  stylus += `[role="switch"]\n  accent-color $mauve\n`;

  stylus += `\n/* Disabled states */\n`;
  stylus += `input:disabled, select:disabled, textarea:disabled, button:disabled, [aria-disabled="true"]\n  opacity .6\n  cursor not-allowed\n`;

  stylus += `\n/* Select dropdown options */\n`;
  stylus += `select, option\n  background $base\n  color $text\n`;

  stylus += `\n/* Horizontal rules */\n`;
  stylus += `hr\n  border-color $overlay1\n  opacity .6\n`;

  stylus += `\n/* Tables (base) - color only, no layout changes */\n`;
  stylus += `table\n  background $base\n`;
  stylus += `thead\n  background $surface0\n  color $text\n`;
  // Do not set padding, border width, spacing, or collapse to avoid affecting layout
  stylus += `tbody tr:nth-child(even)\n  background fade($surface0, .6)\n`;
  stylus += `tbody tr:hover\n  background fade($mauve, .08)\n`;

  stylus += `\n/* Cards / panels / containers (color-only) */\n`;
  stylus += `.card, .panel, .box, .container, .paper, .well\n  background fade($surface0, .9)\n  border 1px solid $surface2\n  border-radius 12px\n  box-shadow 0 8px 24px rgba($overlay2, .18)\n  backdrop-filter blur(4px)\n`;

  stylus += `\n/* Tooltips & popovers (color-only) */\n`;
  stylus += `[role="tooltip"], .tooltip, .popover\n  background $mantle\n  color $text\n  border 1px solid $overlay1\n  box-shadow 0 6px 18px rgba($overlay2, .2)\n`;

  stylus += `\n/* Dropdown menus (color-only) */\n`;
  stylus += `.menu, .dropdown-menu, [role="menu"]\n  background $base\n  border 1px solid $overlay1\n  box-shadow 0 10px 24px rgba($overlay2, .18)\n`;
  stylus += `.menu-item, [role="menuitem"], .dropdown-item\n  color $text\n`;
  stylus += `.menu-item:hover, [role="menuitem"]:hover, .dropdown-item:hover\n  background fade($mauve, .1)\n  color $text\n`;

  stylus += `\n/* Modals & dialogs (color-only) */\n`;
  stylus += `.modal, .dialog, [role="dialog"], [aria-modal="true"]\n  background $base\n  color $text\n  border 1px solid $overlay1\n  box-shadow 0 20px 48px rgba($overlay2, .25)\n`;
  stylus += `.modal-backdrop, .overlay, .backdrop\n  background rgba($crust, .7)\n`;

  stylus += `\n/* Alerts / banners (color-only; no border widths) */\n`;
  stylus += `.alert, .banner, .notice\n  background fade($surface0, .9)\n  border 1px solid $surface2\n  border-left 4px solid $mauve\n  color $text\n`;
  stylus += `.alert-success\n  border-left-color $green\n`;
  stylus += `.alert-warning\n  border-left-color $yellow\n`;
  stylus += `.alert-danger, .alert-error\n  border-left-color $red\n`;
  stylus += `.alert-info\n  border-left-color $blue\n`;

  stylus += `\n/* Badges / chips (color-only) */\n`;
  stylus += `.badge, .tag, .chip\n  background fade($mauve, .2)\n  color $mauve\n  border 1px solid rgba($mauve, .35)\n  border-radius 999px\n`;

  // Tables - Dense variant removed to prevent spacing changes

  // Class-specific styling (from CSS analysis)
  if (cssAnalysis && cssAnalysis.grouped) {
    stylus += `\n/* Class-specific styling (AI CSS analysis) */\n`;
    // Buttons
    if (cssAnalysis.grouped.buttons && cssAnalysis.grouped.buttons.length) {
      cssAnalysis.grouped.buttons.slice(0, 100).forEach((btn: any) => {
        const cls = btn.className;
        if (!cls) return;
        stylus += `.${cls}\n  color $ALT_MAIN\n  &:hover\n    background $surface_0\n    background-image linear-gradient(135deg, $ALT_MAIN 0%, $ALT_BI 100%)\n    if (${btnContrast} < 4.5)\n      color $text\n    else\n      color $ALT_MAIN\n`;
      });
    }
    // Links
    if (cssAnalysis.grouped.links && cssAnalysis.grouped.links.length) {
      cssAnalysis.grouped.links.slice(0, 100).forEach((link: any) => {
        const cls = link.className;
        if (!cls) return;
        stylus += `a.${cls}, .${cls} a\n  color ${defaultAccent}\n`;
        stylus += `a.${cls}:hover, .${cls} a:hover\n  if (${contrast} < 4.5)\n    color $text\n  else\n    color ${defaultAccent}\n  @supports ((-webkit-background-clip: text) and (-webkit-text-fill-color: transparent))\n    background linear-gradient(${hoverAngle}deg, ${defaultAccent} 0%, $bi-accent1 100%)\n    -webkit-background-clip text\n    -webkit-text-fill-color transparent\n`;
      });
    }
    // Backgrounds
    if (cssAnalysis.grouped.backgrounds && cssAnalysis.grouped.backgrounds.length) {
      cssAnalysis.grouped.backgrounds.slice(0, 100).forEach((bg: any) => {
        const cls = bg.className; if (!cls) return;
        stylus += `.${cls}\n  background $surface_0 !important\n`;
      });
    }
    // Text
    if (cssAnalysis.grouped.text && cssAnalysis.grouped.text.length) {
      cssAnalysis.grouped.text.slice(0, 100).forEach((txt: any) => {
        const cls = txt.className; if (!cls) return;
        stylus += `.${cls}\n  color $text !important\n`;
      });
    }
    // Borders (color-only)
    if (cssAnalysis.grouped.borders && cssAnalysis.grouped.borders.length) {
      cssAnalysis.grouped.borders.slice(0, 100).forEach((br: any) => {
        const cls = br.className; if (!cls) return;
        stylus += `.${cls}\n  border-color $overlay_1 !important\n.${cls}:hover\n  border-color $bi-accent1 !important\n`;
      });
    }
  }

  return stylus;
}

function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

function generateVarName(color: string): string {
  // Convert color to variable name
  return color.replace(/[^a-zA-Z0-9]/g, '_').toLowerCase();
}

function sanitizeKey(key: string): string {
  return key.replace(/[^a-z0-9]/gi, '_').toLowerCase();
}

function roleToVar(role: string): string {
  return role.replace(/\./g, '-');
}

function groupMappingsByPurpose(mappings: ColorMapping[]): Record<string, ColorMapping[]> {
  const groups: Record<string, ColorMapping[]> = {
    'Backgrounds': [],
    'Text': [],
    'Buttons': [],
    'Interactive Elements': [],
    'Borders & Dividers': [],
    'Cards & Surfaces': [],
    'Status Indicators': [],
    'Other': []
  };

  mappings.forEach(mapping => {
    const reason = mapping.reason.toLowerCase();

    if (reason.includes('background') || reason.includes('page bg')) {
      groups['Backgrounds'].push(mapping);
    } else if (reason.includes('text') || reason.includes('heading') || reason.includes('body')) {
      groups['Text'].push(mapping);
    } else if (reason.includes('button')) {
      groups['Buttons'].push(mapping);
    } else if (reason.includes('link') || reason.includes('hover') || reason.includes('active') || reason.includes('focus')) {
      groups['Interactive Elements'].push(mapping);
    } else if (reason.includes('border') || reason.includes('divider')) {
      groups['Borders & Dividers'].push(mapping);
    } else if (reason.includes('card') || reason.includes('panel') || reason.includes('surface')) {
      groups['Cards & Surfaces'].push(mapping);
    } else if (reason.includes('success') || reason.includes('error') || reason.includes('warning') || reason.includes('danger') || reason.includes('info')) {
      groups['Status Indicators'].push(mapping);
    } else {
      groups['Other'].push(mapping);
    }
  });

  // Remove empty groups
  return Object.fromEntries(
    Object.entries(groups).filter(([_, mappings]) => mappings.length > 0)
  );
}
